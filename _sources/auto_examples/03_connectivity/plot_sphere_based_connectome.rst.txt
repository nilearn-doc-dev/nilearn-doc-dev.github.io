
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/03_connectivity/plot_sphere_based_connectome.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_03_connectivity_plot_sphere_based_connectome.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_03_connectivity_plot_sphere_based_connectome.py:


Extract signals on spheres and plot a connectome
==============================================================

This example shows how to extract signals from spherical regions.
We show how to build spheres around user-defined coordinates, as well as
centered on coordinates from the Power-264 atlas [1], and the Dosenbach-160
atlas [2].

**References**

[1] Power, Jonathan D., et al. "Functional network organization of the
human brain." Neuron 72.4 (2011): 665-678.

[2] Dosenbach N.U., Nardos B., et al. "Prediction of individual brain maturity
using fMRI.", 2010, Science 329, 1358-1361.

We estimate connectomes using two different methods: **sparse inverse
covariance** and **partial_correlation**, to recover the functional brain
**networks structure**.

We'll start by extracting signals from Default Mode Network regions and
computing a connectome from them.

.. GENERATED FROM PYTHON SOURCE LINES 28-33

Retrieve the brain development fmri dataset
-------------------------------------------

We are going to use a subject from the development functional
connectivity dataset.

.. GENERATED FROM PYTHON SOURCE LINES 33-42

.. code-block:: default


    from nilearn import datasets
    dataset = datasets.fetch_development_fmri(n_subjects=10)

    # print basic information on the dataset
    print('First subject functional nifti image (4D) is at: %s' %
          dataset.func[0])  # 4D data



.. GENERATED FROM PYTHON SOURCE LINES 43-45

Coordinates of Default Mode Network
------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 45-53

.. code-block:: default

    dmn_coords = [(0, -52, 18), (-46, -68, 32), (46, -68, 32), (1, 50, -5)]
    labels = [
        'Posterior Cingulate Cortex',
        'Left Temporoparietal junction',
        'Right Temporoparietal junction',
        'Medial prefrontal cortex',
        ]


.. GENERATED FROM PYTHON SOURCE LINES 54-62

Extracts signal from sphere around DMN seeds
----------------------------------------------

We can compute the mean signal within **spheres** of a fixed radius
around a sequence of (x, y, z) coordinates with the object
:class:`nilearn.maskers.NiftiSpheresMasker`.
The resulting signal is then prepared by the masker object: Detrended,
band-pass filtered and **standardized to 1 variance**.

.. GENERATED FROM PYTHON SOURCE LINES 62-79

.. code-block:: default


    from nilearn.maskers import NiftiSpheresMasker

    masker = NiftiSpheresMasker(
        dmn_coords, radius=8, detrend=True, standardize=True,
        low_pass=0.1, high_pass=0.01, t_r=2,
        memory='nilearn_cache', memory_level=1, verbose=2)

    # Additionally, we pass confound information to ensure our extracted
    # signal is cleaned from confounds.

    func_filename = dataset.func[0]
    confounds_filename = dataset.confounds[0]

    time_series = masker.fit_transform(func_filename,
                                       confounds=[confounds_filename])


.. GENERATED FROM PYTHON SOURCE LINES 80-82

Display time series
--------------------

.. GENERATED FROM PYTHON SOURCE LINES 82-94

.. code-block:: default

    import matplotlib.pyplot as plt

    for time_serie, label in zip(time_series.T, labels):
        plt.plot(time_serie, label=label)

    plt.title('Default Mode Network Time Series')
    plt.xlabel('Scan number')
    plt.ylabel('Normalized signal')
    plt.legend()
    plt.tight_layout()



.. GENERATED FROM PYTHON SOURCE LINES 95-100

Compute partial correlation matrix
-----------------------------------
Using object :class:`nilearn.connectome.ConnectivityMeasure`: Its
default covariance estimator is Ledoit-Wolf, allowing to obtain accurate
partial correlations.

.. GENERATED FROM PYTHON SOURCE LINES 100-107

.. code-block:: default


    from nilearn.connectome import ConnectivityMeasure
    connectivity_measure = ConnectivityMeasure(kind='partial correlation')
    partial_correlation_matrix = connectivity_measure.fit_transform(
        [time_series])[0]



.. GENERATED FROM PYTHON SOURCE LINES 108-113

Display connectome
-------------------

We display the graph of connections with
`:func: nilearn.plotting.plot_connectome`.

.. GENERATED FROM PYTHON SOURCE LINES 113-120

.. code-block:: default


    from nilearn import plotting

    plotting.plot_connectome(partial_correlation_matrix, dmn_coords,
                             title="Default Mode Network Connectivity")



.. GENERATED FROM PYTHON SOURCE LINES 121-123

Display connectome with hemispheric projections.
Notice (0, -52, 18) is included in both hemispheres since x == 0.

.. GENERATED FROM PYTHON SOURCE LINES 123-130

.. code-block:: default

    plotting.plot_connectome(partial_correlation_matrix, dmn_coords,
                             title="Connectivity projected on hemispheres",
                             display_mode='lyrz')

    plotting.show()



.. GENERATED FROM PYTHON SOURCE LINES 131-137

3D visualization in a web browser
---------------------------------
An alternative to :func:`nilearn.plotting.plot_connectome` is to use
:func:`nilearn.plotting.view_connectome`, which gives more interactive
visualizations in a web browser. See :ref:`interactive-connectome-plotting`
for more details.

.. GENERATED FROM PYTHON SOURCE LINES 137-145

.. code-block:: default



    view = plotting.view_connectome(partial_correlation_matrix, dmn_coords)

    # In a Jupyter notebook, if ``view`` is the output of a cell, it will
    # be displayed below the cell
    view


.. GENERATED FROM PYTHON SOURCE LINES 146-151

.. code-block:: default


    # uncomment this to open the plot in a web browser:
    # view.open_in_browser()



.. GENERATED FROM PYTHON SOURCE LINES 152-160

Extract signals on spheres from an atlas
----------------------------------------

Next, instead of supplying our own coordinates, we will use coordinates
generated at the center of mass of regions from two different atlases.
This time, we'll use a different correlation measure.

First we fetch the coordinates of the Power atlas

.. GENERATED FROM PYTHON SOURCE LINES 160-165

.. code-block:: default


    power = datasets.fetch_coords_power_2011()
    print('Power atlas comes with {0}.'.format(power.keys()))



.. GENERATED FROM PYTHON SOURCE LINES 166-172

.. note::


    You can retrieve the coordinates for any atlas, including atlases
    not included in nilearn, using
    :func:`nilearn.plotting.find_parcellation_cut_coords`.

.. GENERATED FROM PYTHON SOURCE LINES 175-179

Compute within spheres averaged time-series
-------------------------------------------

We collect the regions coordinates in a numpy array

.. GENERATED FROM PYTHON SOURCE LINES 179-186

.. code-block:: default

    import numpy as np

    coords = np.vstack((power.rois['x'], power.rois['y'], power.rois['z'])).T

    print('Stacked power coordinates in array of shape {0}.'.format(coords.shape))



.. GENERATED FROM PYTHON SOURCE LINES 187-188

and define spheres masker, with small enough radius to avoid regions overlap.

.. GENERATED FROM PYTHON SOURCE LINES 188-197

.. code-block:: default


    spheres_masker = NiftiSpheresMasker(
        seeds=coords, smoothing_fwhm=6, radius=5.,
        detrend=True, standardize=True, low_pass=0.1, high_pass=0.01, t_r=2)

    timeseries = spheres_masker.fit_transform(func_filename,
                                              confounds=confounds_filename)



.. GENERATED FROM PYTHON SOURCE LINES 198-203

Estimate correlations
---------------------

We start by estimating the signal **covariance** matrix. Here the
number of ROIs exceeds the number of samples,

.. GENERATED FROM PYTHON SOURCE LINES 203-206

.. code-block:: default

    print('time series has {0} samples'.format(timeseries.shape[0]))



.. GENERATED FROM PYTHON SOURCE LINES 207-209

in which situation the graphical lasso **sparse inverse covariance**
estimator captures well the covariance **structure**.

.. GENERATED FROM PYTHON SOURCE LINES 209-218

.. code-block:: default

    try:
        from sklearn.covariance import GraphicalLassoCV
    except ImportError:
        # for Scitkit-Learn < v0.20.0
        from sklearn.covariance import GraphLassoCV as GraphicalLassoCV

    covariance_estimator = GraphicalLassoCV(cv=3, verbose=1)



.. GENERATED FROM PYTHON SOURCE LINES 219-220

We just fit our regions signals into the `GraphicalLassoCV` object

.. GENERATED FROM PYTHON SOURCE LINES 220-223

.. code-block:: default

    covariance_estimator.fit(timeseries)



.. GENERATED FROM PYTHON SOURCE LINES 224-225

and get the ROI-to-ROI covariance matrix.

.. GENERATED FROM PYTHON SOURCE LINES 225-229

.. code-block:: default

    matrix = covariance_estimator.covariance_
    print('Covariance matrix has shape {0}.'.format(matrix.shape))



.. GENERATED FROM PYTHON SOURCE LINES 230-235

Plot matrix, graph, and strength
--------------------------------

We use `:func: nilearn.plotting.plot_matrix` to visualize our correlation matrix
and display the graph of connections with `nilearn.plotting.plot_connectome`.

.. GENERATED FROM PYTHON SOURCE LINES 235-245

.. code-block:: default

    from nilearn import plotting

    plotting.plot_matrix(matrix, vmin=-1., vmax=1., colorbar=True,
                         title='Power correlation matrix')

    # Tweak edge_threshold to keep only the strongest connections.
    plotting.plot_connectome(matrix, coords, title='Power correlation graph',
                             edge_threshold='99.8%', node_size=20, colorbar=True)



.. GENERATED FROM PYTHON SOURCE LINES 246-251

.. note::

    Note the 1. on the matrix diagonal: These are the signals variances, set
    to 1. by the `spheres_masker`. Hence the covariance of the signal is a
    correlation matrix.

.. GENERATED FROM PYTHON SOURCE LINES 254-257

Sometimes, the information in the correlation matrix is overwhelming and
aggregating edge strength from the graph would help. Use the function
`nilearn.plotting.plot_markers` to visualize this information.

.. GENERATED FROM PYTHON SOURCE LINES 257-269

.. code-block:: default


    # calculate normalized, absolute strength for each node
    node_strength = np.sum(np.abs(matrix), axis=0)
    node_strength /= np.max(node_strength)

    plotting.plot_markers(
        node_strength,
        coords,
        title='Node strength for absolute value of edges for Power atlas',
    )



.. GENERATED FROM PYTHON SOURCE LINES 270-273

From the correlation matrix, we observe that there is a positive and negative
structure. We could make two different plots, one for the positive and one for
the negative structure.

.. GENERATED FROM PYTHON SOURCE LINES 273-304

.. code-block:: default


    from matplotlib.pyplot import cm

    # clip connectivity matrix to preserve positive and negative edges
    positive_edges = np.clip(matrix, 0, matrix.max())
    negative_edges = np.clip(matrix, matrix.min(), 0)

    # calculate strength for positive edges
    node_strength_positive = np.sum(np.abs(positive_edges), axis=0)
    node_strength_positive /= np.max(node_strength_positive)

    # calculate strength for negative edges
    node_strength_negative = np.sum(np.abs(negative_edges), axis=0)
    node_strength_negative /= np.max(node_strength_negative)

    # plot nodes' strength for positive edges
    plotting.plot_markers(
        node_strength_positive,
        coords,
        title='Node strength for the positive edges for Power atlas',
        node_cmap=cm.YlOrRd
    )

    # plot nodes' strength for negative edges
    plotting.plot_markers(
        node_strength_negative,
        coords,
        title='Node strength for the negative edges for Power atlas',
        node_cmap=cm.PuBu
    )


.. GENERATED FROM PYTHON SOURCE LINES 305-309

Connectome extracted from Dosenbach's atlas
-------------------------------------------

We repeat the same steps for Dosenbach's atlas.

.. GENERATED FROM PYTHON SOURCE LINES 309-371

.. code-block:: default

    dosenbach = datasets.fetch_coords_dosenbach_2010()

    coords = np.vstack((
        dosenbach.rois['x'],
        dosenbach.rois['y'],
        dosenbach.rois['z'],
    )).T

    spheres_masker = NiftiSpheresMasker(
        seeds=coords, smoothing_fwhm=6, radius=4.5,
        detrend=True, standardize=True, low_pass=0.1, high_pass=0.01, t_r=2)

    timeseries = spheres_masker.fit_transform(func_filename,
                                              confounds=confounds_filename)

    covariance_estimator = GraphicalLassoCV()
    covariance_estimator.fit(timeseries)
    matrix = covariance_estimator.covariance_

    plotting.plot_matrix(matrix, vmin=-1., vmax=1., colorbar=True,
                         title='Dosenbach correlation matrix')

    plotting.plot_connectome(matrix, coords, title='Dosenbach correlation graph',
                             edge_threshold="99.7%", node_size=20, colorbar=True)


    # calculate average strength for each node
    node_strength = np.sum(np.abs(matrix), axis=0)
    node_strength /= np.max(node_strength)

    plotting.plot_markers(
        node_strength,
        coords,
        title='Node strength for absolute value of edges for Dosenbach atlas',
    )

    # clip connectivity matrix to preserve positive and negative edges
    positive_edges = np.clip(matrix, 0, matrix.max())
    negative_edges = np.clip(matrix, matrix.min(), 0)

    # calculate strength for positive and edges
    node_strength_positive = np.sum(np.abs(positive_edges), axis=0)
    node_strength_positive /= np.max(node_strength_positive)
    node_strength_negative = np.sum(np.abs(negative_edges), axis=0)
    node_strength_negative /= np.max(node_strength_negative)

    # plot nodes' strength for positive edges
    plotting.plot_markers(
        node_strength_positive,
        coords,
        title='Node strength for the positive edges for Dosenbach atlas',
        node_cmap=cm.YlOrRd
    )

    # plot nodes' strength for negative edges
    plotting.plot_markers(
        node_strength_negative,
        coords,
        title='Node strength for the negative edges for Dosenbach atlas',
        node_cmap=cm.PuBu
    )


.. GENERATED FROM PYTHON SOURCE LINES 372-373

We can easily identify the Dosenbach's networks from the matrix blocks.

.. GENERATED FROM PYTHON SOURCE LINES 373-377

.. code-block:: default

    print('Dosenbach networks names are {0}'.format(np.unique(dosenbach.networks)))

    plotting.show()


.. GENERATED FROM PYTHON SOURCE LINES 378-383

.. seealso::

   * :ref:`sphx_glr_auto_examples_03_connectivity_plot_atlas_comparison.py`

   * :ref:`sphx_glr_auto_examples_03_connectivity_plot_multi_subject_connectome.py`


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.000 seconds)

**Estimated memory usage:**  0 MB


.. _sphx_glr_download_auto_examples_03_connectivity_plot_sphere_based_connectome.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/nilearn/nilearn.github.io/main?filepath=examples/auto_examples/03_connectivity/plot_sphere_based_connectome.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_sphere_based_connectome.py <plot_sphere_based_connectome.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_sphere_based_connectome.ipynb <plot_sphere_based_connectome.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
